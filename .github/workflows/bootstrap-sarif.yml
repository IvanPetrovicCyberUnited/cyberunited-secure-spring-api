name: Bootstrap Code Scanning (no actions, hardened)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  contents: read
  security-events: write

env:
  GH_API: https://api.github.com
  # Controls
  SEMGREP_TIMEOUT_SECONDS: "420"         # 7 Min
  SEMGREP_MAX_BYTES: "200000000"         # ~200 MB
  UPLOAD_MAX_RETRIES: "3"
  CURL_CONNECT_TIMEOUT: "10"
  CURL_MAX_TIME: "120"
  SARIF_MAX_COMPRESSED: "10485760"       # 10 MiB gz-Limit

jobs:
  bootstrap-sarif:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Install prerequisites (jq, coreutils)
        timeout-minutes: 10
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq coreutils

      - name: Checkout repository (manual, no actions)
        timeout-minutes: 10
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          if [ -z "${GITHUB_TOKEN:-}" ]; then
            echo "GITHUB_TOKEN missing" >&2; exit 2
          fi
          git init .
          git config --global advice.detachedHead false
          git config --global --add safe.directory "$PWD"
          git config --global gc.auto 0
          git remote add origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO}.git"
          for i in 1 2; do
            if git fetch --depth=1 origin "${SHA}"; then break; fi
            echo "Retry fetch ($i/2)..." >&2; sleep 2
          done
          git checkout --force FETCH_HEAD
          git rev-parse --verify HEAD

      - name: Run Semgrep in Docker and produce SARIF (with limits)
        timeout-minutes: 15
        env:
          SEMGREP_TIMEOUT_SECONDS: ${{ env.SEMGREP_TIMEOUT_SECONDS }}
          SEMGREP_MAX_BYTES: ${{ env.SEMGREP_MAX_BYTES }}
        run: |
          set -euo pipefail
          mkdir -p reports/semgrep
          for i in 1 2 3; do
            if docker pull returntocorp/semgrep:latest; then break; fi
            echo "Retry docker pull semgrep ($i/3)..." >&2; sleep 3
          done
          docker run --rm -v "$PWD:/src" --workdir /src \
            returntocorp/semgrep:latest \
            semgrep --config p/owasp-top-ten --config p/java \
                    --timeout "${SEMGREP_TIMEOUT_SECONDS}" \
                    --max-target-bytes "${SEMGREP_MAX_BYTES}" \
                    --metrics=off \
                    --sarif -o reports/semgrep/semgrep.sarif || true

          # Fallback: minimale leere SARIF mit jq erzeugen
          if [ ! -s reports/semgrep/semgrep.sarif ]; then
            echo "Semgrep SARIF empty – generating minimal SARIF with jq." >&2
            jq -n '{
              "$schema":"https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json",
              "version":"2.1.0",
              "runs":[{"tool":{"driver":{"name":"semgrep"}},"results":[]}]
            }' > reports/semgrep/semgrep.sarif
          fi

      - name: Upload SARIF to GitHub Code Scanning via API (gzip+base64, retries, size check)
        timeout-minutes: 10
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CURL_CONNECT_TIMEOUT: ${{ env.CURL_CONNECT_TIMEOUT }}
          CURL_MAX_TIME: ${{ env.CURL_MAX_TIME }}
          UPLOAD_MAX_RETRIES: ${{ env.UPLOAD_MAX_RETRIES }}
          SARIF_MAX_COMPRESSED: ${{ env.SARIF_MAX_COMPRESSED }}
        run: |
          set -euo pipefail
          test -s reports/semgrep/semgrep.sarif

          # gzip → Datei; Größe prüfen (API-Limit 10 MiB gz)
          gzip -c reports/semgrep/semgrep.sarif > reports/semgrep/semgrep.sarif.gz
          BYTES=$(stat -c%s reports/semgrep/semgrep.sarif.gz)
          echo "Compressed SARIF size: ${BYTES} bytes"
          if [ "$BYTES" -ge "$SARIF_MAX_COMPRESSED" ]; then
            echo "Compressed SARIF exceeds ${SARIF_MAX_COMPRESSED} bytes (10 MiB) – aborting." >&2
            exit 3
          fi

          # base64 → in Datei (kein riesiger Shell-String)
          timeout 60s base64 -w 0 reports/semgrep/semgrep.sarif.gz > reports/semgrep/semgrep.sarif.gz.b64 || {
            echo "base64 encoding timed out" >&2; exit 5; }

          # JSON-Payload ohne große Shell-Variablen (rawfile einbinden)
          jq -n \
            --rawfile sarif_b64 reports/semgrep/semgrep.sarif.gz.b64 \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg tool "semgrep" \
            '{commit_sha:$sha, ref:$ref, sarif:($sarif_b64), tool_name:$tool}' \
            > sarif_payload.json

          # Upload mit Retries; erwartet HTTP 202
          for i in $(seq 1 "${UPLOAD_MAX_RETRIES}"); do
            echo "Uploading SARIF (attempt $i/${UPLOAD_MAX_RETRIES})..."
            HTTP=$(curl -sS -o response.json -w "%{http_code}" \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              --connect-timeout "${CURL_CONNECT_TIMEOUT}" \
              --max-time "${CURL_MAX_TIME}" \
              -X POST "$GH_API/repos/${{ github.repository }}/code-scanning/sarifs" \
              --data @sarif_payload.json) || HTTP="000"
            if [ "$HTTP" = "202" ]; then
              echo "Upload accepted (HTTP 202)."; break
            fi
            echo "Upload failed (HTTP=${HTTP}); retrying in 4s..." >&2
            sleep 4
          done

          if [ "$HTTP" != "202" ]; then
            echo "Final upload failed. Last HTTP code: ${HTTP}. Response:" >&2
            cat response.json >&2 || true
            exit 4
          fi
