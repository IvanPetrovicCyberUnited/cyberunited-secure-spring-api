name: Bootstrap Code Scanning (no actions, hardened)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  contents: read
  security-events: write

env:
  GH_API: https://api.github.com
  # Steuerung/Controls
  SEMGREP_TIMEOUT_SECONDS: "420"         # Max. Laufzeit Semgrep (7 Min)
  SEMGREP_MAX_BYTES: "200000000"         # Max. Bytes der Zielquellen (~200MB)
  UPLOAD_MAX_RETRIES: "3"                # Upload-Versuche
  CURL_CONNECT_TIMEOUT: "10"             # Sek. bis Verbindungsaufbau
  CURL_MAX_TIME: "120"                   # Max. Gesamtdauer eines Upload-Calls (Sek.)
  SARIF_MAX_COMPRESSED: "10485760"       # 10 MiB Limit für gzip+base64 (GitHub Anforderung)

jobs:
  bootstrap-sarif:
    runs-on: ubuntu-latest
    timeout-minutes: 45   # Job-Hardlimit
    steps:
      - name: Install prerequisites (jq, coreutils)
        timeout-minutes: 10
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq coreutils

      - name: Checkout repository (manual, no actions)
        timeout-minutes: 10
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          if [ -z "${GITHUB_TOKEN:-}" ]; then
            echo "GITHUB_TOKEN missing" >&2; exit 2
          fi
          git init .
          git config --global advice.detachedHead false
          git config --global --add safe.directory "$PWD"
          git config --global gc.auto 0
          git remote add origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO}.git"
          # 2 Versuche beim Fetch (kurze Flakes abfangen)
          for i in 1 2; do
            if git fetch --depth=1 origin "${SHA}"; then break; fi
            echo "Retry fetch ($i/2)..." >&2; sleep 2
          done
          git checkout --force FETCH_HEAD
          git rev-parse --verify HEAD

      - name: Run Semgrep in Docker and produce SARIF (with limits)
        timeout-minutes: 15
        env:
          SEMGREP_TIMEOUT_SECONDS: ${{ env.SEMGREP_TIMEOUT_SECONDS }}
          SEMGREP_MAX_BYTES: ${{ env.SEMGREP_MAX_BYTES }}
        run: |
          set -euo pipefail
          mkdir -p reports/semgrep
          # Docker Pull mit 2 Retries
          for i in 1 2 3; do
            if docker pull returntocorp/semgrep:latest; then break; fi
            echo "Retry docker pull semgrep ($i/3)..." >&2; sleep 3
          done
          # Semgrep: Timeout, Größenlimit, keine Telemetrie, SARIF-Ausgabe
          docker run --rm -v "$PWD:/src" --workdir /src \
            returntocorp/semgrep:latest \
            semgrep --config p/owasp-top-ten --config p/java \
                    --timeout "${SEMGREP_TIMEOUT_SECONDS}" \
                    --max-target-bytes "${SEMGREP_MAX_BYTES}" \
                    --metrics=off \
                    --sarif -o reports/semgrep/semgrep.sarif || true

          # Prüfen, ob SARIF existiert und nicht leer ist
          if [ ! -s reports/semgrep/semgrep.sarif ]; then
            echo "Semgrep SARIF empty or missing – nothing to upload (this won't fail the job)." >&2
            # Trotzdem eine minimale leere SARIF erzeugen, damit ‘Require code scanning results’ erfüllt werden kann
            cat > reports/semgrep/semgrep.sarif <<'EOF'
            {
              "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json",
              "version": "2.1.0",
              "runs": [ { "tool": { "driver": { "name": "semgrep" } }, "results": [] } ]
            }
            EOF
          fi

      - name: Upload SARIF to GitHub Code Scanning via API (gzip+base64, retries, size check)
        timeout-minutes: 10
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CURL_CONNECT_TIMEOUT: ${{ env.CURL_CONNECT_TIMEOUT }}
          CURL_MAX_TIME: ${{ env.CURL_MAX_TIME }}
          UPLOAD_MAX_RETRIES: ${{ env.UPLOAD_MAX_RETRIES }}
          SARIF_MAX_COMPRESSED: ${{ env.SARIF_MAX_COMPRESSED }}
        run: |
          set -euo pipefail
          test -s reports/semgrep/semgrep.sarif
          # Komprimieren + base64, dann Größencheck (< 10 MiB)
          gzip -c reports/semgrep/semgrep.sarif > reports/semgrep/semgrep.sarif.gz
          BYTES=$(stat -c%s reports/semgrep/semgrep.sarif.gz)
          echo "Compressed SARIF size: ${BYTES} bytes"
          if [ "$BYTES" -ge "$SARIF_MAX_COMPRESSED" ]; then
            echo "Compressed SARIF exceeds ${SARIF_MAX_COMPRESSED} bytes (10 MiB) – aborting to comply with API limits." >&2
            exit 3
          fi
          SARIF_GZ_B64=$(base64 -w 0 reports/semgrep/semgrep.sarif.gz)

          jq -n --arg sarif "$SARIF_GZ_B64" \
                --arg sha "${{ github.sha }}" \
                --arg ref "${{ github.ref }}" \
                --arg tool "semgrep" \
                '{commit_sha:$sha, ref:$ref, sarif:$sarif, tool_name:$tool}' > sarif_payload.json

          # Upload mit Retries und HTTP-Code-Prüfung (erwartet 202)
          RESP=""
          CODE=0
          for i in $(seq 1 "${UPLOAD_MAX_RETRIES}"); do
            echo "Uploading SARIF (attempt $i/${UPLOAD_MAX_RETRIES})..."
            set +e
            RESP=$(curl -sS -o response.json -w "%{http_code}" \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/sarif+json" \
              --connect-timeout "${CURL_CONNECT_TIMEOUT}" \
              --max-time "${CURL_MAX_TIME}" \
              -X POST "$GH_API/repos/${{ github.repository }}/code-scanning/sarifs" \
              --data @sarif_payload.json)
            CODE=$?
            set -e
            if [ "$CODE" -eq 0 ] && [ "$RESP" = "202" ]; then
              echo "Upload accepted (HTTP 202)."
              break
            fi
            echo "Upload failed (curl_exit=${CODE}, http=${RESP:-n/a}); retrying in 4s..." >&2
            sleep 4
          done

          if [ "$RESP" != "202" ]; then
            echo "Final upload failed. Last HTTP code: ${RESP:-n/a}. Response body:" >&2
            cat response.json >&2 || true
            exit 4
          fi
